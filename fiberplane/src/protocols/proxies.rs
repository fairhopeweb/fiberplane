use super::data_sources::{DataSource, DataSourceStatus};
use super::names::{InvalidName, Name};
use super::providers::Error;
use base64uuid::{Base64Uuid, InvalidId};
use serde::{Deserialize, Serialize};
use std::fmt::{self, Debug, Formatter};
use std::{convert::TryFrom, str::FromStr};
use time::OffsetDateTime;

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct Proxy {
    pub id: Base64Uuid,
    pub name: Name,
    pub status: ProxyStatus,
    pub data_sources: Vec<DataSource>,
    #[serde(skip_deserializing, skip_serializing_if = "Option::is_none")]
    pub token: Option<ProxyToken>,
    pub description: Option<String>,
    pub created_at: OffsetDateTime,
    pub updated_at: OffsetDateTime,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone, Copy)]
#[serde(rename_all = "snake_case")]
pub enum ProxyStatus {
    Connected,
    Disconnected,
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub struct NewProxy {
    pub name: Name,
    pub description: Option<String>,
}

#[derive(Debug, thiserror::Error, PartialEq, Eq)]
pub enum InvalidProxyToken {
    #[error("Invalid workspace ID")]
    InvalidWorkspaceId(#[from] InvalidId),
    #[error("Invalid proxy name")]
    InvalidProxyName(#[from] InvalidName),
    #[error("Missing token")]
    MissingToken,
}

/// This represents the auth token that is generated by the API and used
/// by the proxy to authenticate its websocket connection.
#[derive(Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(try_from = "&str", into = "String")]
pub struct ProxyToken {
    pub workspace_id: Base64Uuid,
    pub proxy_name: Name,
    pub token: String,
}

impl Debug for ProxyToken {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("ProxyToken")
            .field("workspace_id", &self.workspace_id)
            .field("proxy_name", &self.proxy_name)
            .field("token", &"[REDACTED]")
            .finish()
    }
}

impl From<ProxyToken> for String {
    fn from(token: ProxyToken) -> Self {
        format!(
            "{}:{}:{}",
            token.workspace_id.to_string(),
            token.proxy_name.to_string(),
            token.token
        )
    }
}

impl FromStr for ProxyToken {
    type Err = InvalidProxyToken;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut parts = s.split(':');

        let workspace_id = parts.next().unwrap_or_default().parse::<Base64Uuid>()?;
        let proxy_name = Name::new(parts.next().unwrap_or_default())?;
        let token = parts
            .next()
            .ok_or(InvalidProxyToken::MissingToken)?
            .to_string();

        Ok(ProxyToken {
            workspace_id,
            proxy_name,
            token,
        })
    }
}

impl TryFrom<&str> for ProxyToken {
    type Error = InvalidProxyToken;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        Self::from_str(s)
    }
}

/// Messages sent to the Proxy
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ServerMessage {
    InvokeProxy(InvokeProxyMessage),
}

impl ServerMessage {
    pub fn deserialize_msgpack(
        input: impl AsRef<[u8]>,
    ) -> Result<ServerMessage, rmp_serde::decode::Error> {
        rmp_serde::from_slice(input.as_ref())
    }

    pub fn serialize_msgpack(&self) -> Vec<u8> {
        rmp_serde::to_vec(&self).expect("MessgePack serialization error")
    }

    pub fn op_id(&self) -> Option<Base64Uuid> {
        match self {
            ServerMessage::InvokeProxy(message) => Some(message.op_id),
        }
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct InvokeProxyMessage {
    pub op_id: Base64Uuid,
    pub data_source_name: Name,
    #[serde(with = "serde_bytes")]
    pub data: Vec<u8>,
    pub protocol_version: u8,
}

impl Debug for InvokeProxyMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("InvokeProxyMessage")
            .field("op_id", &self.op_id)
            .field("data_source_name", &self.data_source_name)
            .field("data", &format!("[{} bytes]", self.data.len()))
            .finish()
    }
}

/// Messages sent from the Proxy
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ProxyMessage {
    SetDataSources(SetDataSourcesMessage),
    InvokeProxyResponse(InvokeProxyResponseMessage),
    Error(ErrorMessage),
}

impl From<ErrorMessage> for ProxyMessage {
    fn from(message: ErrorMessage) -> Self {
        ProxyMessage::Error(message)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct InvokeProxyResponseMessage {
    pub op_id: Base64Uuid,
    #[serde(with = "serde_bytes")]
    pub data: Vec<u8>,
}

impl Debug for InvokeProxyResponseMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("InvokeProxyResponseMessage")
            .field("op_id", &self.op_id)
            .field("data", &format!("[{} bytes]", self.data.len()))
            .finish()
    }
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ErrorMessage {
    pub op_id: Base64Uuid,
    pub error: Error,
}

impl ProxyMessage {
    pub fn deserialize_msgpack(
        input: impl AsRef<[u8]>,
    ) -> Result<ProxyMessage, rmp_serde::decode::Error> {
        rmp_serde::from_slice(input.as_ref())
    }

    pub fn serialize_msgpack(&self) -> Vec<u8> {
        rmp_serde::to_vec_named(&self).expect("MessgePack serialization error")
    }

    pub fn op_id(&self) -> Option<Base64Uuid> {
        match self {
            ProxyMessage::InvokeProxyResponse(message) => Some(message.op_id),
            ProxyMessage::Error(error) => Some(error.op_id),
            ProxyMessage::SetDataSources(_) => None,
        }
    }
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SetDataSourcesMessage {
    pub data_sources: Vec<UpsertProxyDataSource>,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Eq, Clone)]
#[serde(tag = "type", rename_all = "camelCase")]
pub struct UpsertProxyDataSource {
    pub name: Name,
    pub description: Option<String>,
    pub provider_type: String,
    #[serde(flatten)]
    pub status: DataSourceStatus,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::protocols::providers::Error;

    #[test]
    fn serialization_deserialization() {
        let data_sources = vec![
            UpsertProxyDataSource {
                name: Name::from_static("prometheus-prod"),
                provider_type: "prometheus".to_string(),
                description: Some("Production Prometheus".to_string()),
                status: DataSourceStatus::Connected,
            },
            UpsertProxyDataSource {
                name: Name::from_static("elasticsearch-prod"),
                provider_type: "elasticsearch".to_string(),
                description: None,
                status: DataSourceStatus::Error(Error::NotFound),
            },
        ];
        let message = ProxyMessage::SetDataSources(SetDataSourcesMessage {
            data_sources: data_sources.clone(),
        });
        let serialized = message.serialize_msgpack();
        let deserialized = ProxyMessage::deserialize_msgpack(serialized).unwrap();
        if let ProxyMessage::SetDataSources(set_data_sources) = deserialized {
            assert_eq!(set_data_sources.data_sources, data_sources)
        } else {
            panic!("Unexpected message type");
        }
    }
}
